#!/usr/bin/env bash

EXTENDED_HELP=$(cat <<- EOH
Script for controlling Philips CX5120 (Philips heater series 5000) air purifier via aioairctrl.
the available actions aqnd arguments are:
  status                        - get the current status of the device
  start|on                      - start the device
  stop|off                      - stop the device
  swing on|off                  - enable or disable swing mode
  mode vent|low|high|auto       - set the operating mode
  set_temp|temp 1-37          - set target temperature (1-37 degrees Celsius) and enable auto mode
  beep on|off                   - enable or disable beep sound
  set key=value key=value ... - set one or more settings by their key names. any key returned by 'status' can be set this way, but without any checks.
                                  prefer e.g. set_temp for the range check.

Using --restriction-to-beep-disabled option, only executes the action if the beep is disabled.
This makes it possible to turn off the device automation using this script by enabling the beep. The script will then not intervene on top of user automation.
The actions 'status' and 'beep' are exempted from this restriction and will always be executed, regardless of the --restriction-to-beep-disabled optoin.
--restriction-to-beep-disabled needs the jq (JSON processor) command line tool to be installed.


Supplying --no-restriction-to-pingable will send commands regardless of whether the device is pingable or not.
By default, the script will only send commands if the device is pingable.

Use -v to increase verbosity, can be supplied multiple times for more verbosity. supplyiong it one time
logs major steps and restriction statuses, supplying it twice logs the actual aioairctrl commands that are executed.

EOH
)
# Created by argbash-init v2.11.0
# ARG_OPTIONAL_SINGLE([device],[d],[The device to control],["$AIOAIR_DEVICE_IP"])
# ARG_POSITIONAL_INF([action_with_args],[The action followed by its arguments multiple actions followed by their arguments can be supplied])
# ARG_OPTIONAL_BOOLEAN([restriction-to-beep-disabled],[B],[Restrict actions and only act if beep is disabled],[off])
# ARG_OPTIONAL_BOOLEAN([restriction-to-pingable],[],[Restrict actions and only act if ],[on])

# ARG_DEFAULTS_POS()
# ARG_HELP([Script for controlling Philips CX5120 (Philips heater series 5000) air purifier via aioairctrl.],[$EXTENDED_HELP])
# ARG_VERBOSE([v],[turn on debug mode (can be supplied multiple tomes)])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.11.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='dBhv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_action_with_args=()
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_device="$AIOAIR_DEVICE_IP"
_arg_restriction_to_beep_disabled="off"
_arg_restriction_to_pingable="on"
_arg_verbose=0


print_help()
{
	printf '%s\n' "Script for controlling Philips CX5120 (Philips heater series 5000) air purifier via aioairctrl."
	printf 'Usage: %s [-d|--device <arg>] [-B|--(no-)restriction-to-beep-disabled] [--(no-)restriction-to-pingable] [-h|--help] [-v|--verbose] [<action_with_args-1>] ... [<action_with_args-n>] ...\n' "$0"
	printf '\t%s\n' "<action_with_args>: The action followed by its arguments multiple actions followed by their arguments can be supplied"
	printf '\t%s\n' "-d, --device: The device to control (default: '"$AIOAIR_DEVICE_IP"')"
	printf '\t%s\n' "-B, --restriction-to-beep-disabled, --no-restriction-to-beep-disabled: Restrict actions and only act if beep is disabled (off by default)"
	printf '\t%s\n' "--restriction-to-pingable, --no-restriction-to-pingable: Restrict actions and only act if  (on by default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --verbose: Set verbose output (can be specified multiple times to increase the effect)"
	printf '\n%s\n' "$EXTENDED_HELP"
}


parse_commandline()
{
	_positionals_count=0
	local _key
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-d|--device)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_device="$2"
				shift
				;;
			--device=*)
				_arg_device="${_key##--device=}"
				;;
			-d*)
				_arg_device="${_key##-d}"
				;;
			-B|--no-restriction-to-beep-disabled|--restriction-to-beep-disabled)
				_arg_restriction_to_beep_disabled="on"
				test "${1:0:5}" = "--no-" && _arg_restriction_to_beep_disabled="off"
				;;
			-B*)
				_arg_restriction_to_beep_disabled="on"
				_next="${_key##-B}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-B" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			--no-restriction-to-pingable|--restriction-to-pingable)
				_arg_restriction_to_pingable="on"
				test "${1:0:5}" = "--no-" && _arg_restriction_to_pingable="off"
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--verbose)
				_arg_verbose=$((_arg_verbose + 1))
				;;
			-v*)
				_arg_verbose=$((_arg_verbose + 1))
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names=""
	_our_args=$((${#_positionals[@]} - 0))
	for ((ii = 0; ii < _our_args; ii++))
	do
		_positional_names="$_positional_names _arg_action_with_args[$((ii + 0))]"
	done

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
