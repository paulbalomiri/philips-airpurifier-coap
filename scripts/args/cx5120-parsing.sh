#!/usr/bin/env bash

EXTENDED_HELP=$(cat <<- EOH
Script for controlling Philips CX5120 (Philips heater series 5000) air purifier via aioairctrl.
the available actions are:
  status                     - get the current status of the device
  start|on value           - start the device, optional value to send as D03102 (default: 1, should not be changed)
  stop|off value           - stop the device, optional value to send as D03102 (default: 0, should not be changed)
  swing on|off             - enable or disable swing mode
  mode vent|low|high|auto  - set the operating mode
  set_temp|temp 1-37      - set target temperature (1-37 degrees Celsius) and enable auto mode
  beep on|off             - enable or disable beep sound

For scripts using --restriction-to-beep-disabled option, only executes the action if the beep is disabled.
This makes it possible to turn off the device automation using this script by enabling the beep. The script will then not intervene on top of user automation.
The actions 'status' and 'beep' are exempted from this restriction and will always be executed, regardless of the --restriction-to-beep-disabled opton.
EOH
)
# Created by argbash-init v2.11.0
# ARG_OPTIONAL_SINGLE([device],[d],[The device to control],["$AIOAIR_DEVICE_IP"])
# ARG_POSITIONAL_SINGLE([action])
# ARG_POSITIONAL_SINGLE([value],["The value associated with the action"],[""])
# ARG_OPTIONAL_BOOLEAN([restriction-to-beep-disabled],[b],[Restrict actions and only act if beep is disabled],[off])
# ARG_DEFAULTS_POS()
# ARG_HELP([Script for controlling Philips CX5120 (Philips heater series 5000) air purifier via aioairctrl.],[$EXTENDED_HELP])
# ARG_VERBOSE([v],[turn on debug mode (can be supplied multiple tomes)])
# ARGBASH_GO()
# needed because of Argbash --> m4_ignore([
### START OF CODE GENERATED BY Argbash v2.11.0 one line above ###
# Argbash is a bash code generator used to get arguments parsing right.
# Argbash is FREE SOFTWARE, see https://argbash.dev for more info


die()
{
	local _ret="${2:-1}"
	test "${_PRINT_HELP:-no}" = yes && print_help >&2
	echo "$1" >&2
	exit "${_ret}"
}


begins_with_short_option()
{
	local first_option all_short_options='dbhv'
	first_option="${1:0:1}"
	test "$all_short_options" = "${all_short_options/$first_option/}" && return 1 || return 0
}

# THE DEFAULTS INITIALIZATION - POSITIONALS
_positionals=()
_arg_action=
_arg_value=""
# THE DEFAULTS INITIALIZATION - OPTIONALS
_arg_device="$AIOAIR_DEVICE_IP"
_arg_restriction_to_beep_disabled="off"
_arg_verbose=0


print_help()
{
	printf '%s\n' "Script for controlling Philips CX5120 (Philips heater series 5000) air purifier via aioairctrl."
	printf 'Usage: %s [-d|--device <arg>] [-b|--(no-)restriction-to-beep-disabled] [-h|--help] [-v|--verbose] <action> [<value>]\n' "$0"
	printf '\t%s\n' "<value>: \"The value associated with the action\" (default: '""')"
	printf '\t%s\n' "-d, --device: The device to control (default: '"$AIOAIR_DEVICE_IP"')"
	printf '\t%s\n' "-b, --restriction-to-beep-disabled, --no-restriction-to-beep-disabled: Restrict actions and only act if beep is disabled (off by default)"
	printf '\t%s\n' "-h, --help: Prints help"
	printf '\t%s\n' "-v, --verbose: Set verbose output (can be specified multiple times to increase the effect)"
	printf '\n%s\n' "$EXTENDED_HELP"
}


parse_commandline()
{
	_positionals_count=0
	local _key
	while test $# -gt 0
	do
		_key="$1"
		case "$_key" in
			-d|--device)
				test $# -lt 2 && die "Missing value for the optional argument '$_key'." 1
				_arg_device="$2"
				shift
				;;
			--device=*)
				_arg_device="${_key##--device=}"
				;;
			-d*)
				_arg_device="${_key##-d}"
				;;
			-b|--no-restriction-to-beep-disabled|--restriction-to-beep-disabled)
				_arg_restriction_to_beep_disabled="on"
				test "${1:0:5}" = "--no-" && _arg_restriction_to_beep_disabled="off"
				;;
			-b*)
				_arg_restriction_to_beep_disabled="on"
				_next="${_key##-b}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-b" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			-h|--help)
				print_help
				exit 0
				;;
			-h*)
				print_help
				exit 0
				;;
			-v|--verbose)
				_arg_verbose=$((_arg_verbose + 1))
				;;
			-v*)
				_arg_verbose=$((_arg_verbose + 1))
				_next="${_key##-v}"
				if test -n "$_next" -a "$_next" != "$_key"
				then
					{ begins_with_short_option "$_next" && shift && set -- "-v" "-${_next}" "$@"; } || die "The short option '$_key' can't be decomposed to ${_key:0:2} and -${_key:2}, because ${_key:0:2} doesn't accept value and '-${_key:2:1}' doesn't correspond to a short option."
				fi
				;;
			*)
				_last_positional="$1"
				_positionals+=("$_last_positional")
				_positionals_count=$((_positionals_count + 1))
				;;
		esac
		shift
	done
}


handle_passed_args_count()
{
	local _required_args_string="'action'"
	test "${_positionals_count}" -ge 1 || _PRINT_HELP=yes die "FATAL ERROR: Not enough positional arguments - we require between 1 and 2 (namely: $_required_args_string), but got only ${_positionals_count}." 1
	test "${_positionals_count}" -le 2 || _PRINT_HELP=yes die "FATAL ERROR: There were spurious positional arguments --- we expect between 1 and 2 (namely: $_required_args_string), but got ${_positionals_count} (the last one was: '${_last_positional}')." 1
}


assign_positional_args()
{
	local _positional_name _shift_for=$1
	_positional_names="_arg_action _arg_value "

	shift "$_shift_for"
	for _positional_name in ${_positional_names}
	do
		test $# -gt 0 || break
		eval "$_positional_name=\${1}" || die "Error during argument parsing, possibly an Argbash bug." 1
		shift
	done
}

parse_commandline "$@"
handle_passed_args_count
assign_positional_args 1 "${_positionals[@]}"

# OTHER STUFF GENERATED BY Argbash

### END OF CODE GENERATED BY Argbash (sortof) ### ])
